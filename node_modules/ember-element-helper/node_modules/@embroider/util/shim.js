"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addonV1Shim = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const shared_internals_1 = require("@embroider/shared-internals");
const broccoli_funnel_1 = __importDefault(require("broccoli-funnel"));
const MIN_SUPPORT_LEVEL = 1;
function addonMeta(pkgJSON) {
    let meta = pkgJSON['ember-addon'];
    if ((meta === null || meta === void 0 ? void 0 : meta.version) !== 2 || (meta === null || meta === void 0 ? void 0 : meta.type) !== 'addon') {
        throw new Error(`did not find valid v2 addon metadata in ${pkgJSON.name}`);
    }
    return meta;
}
function addonV1Shim(directory, options = {}) {
    let pkg = JSON.parse(fs_1.readFileSync(path_1.resolve(directory, './package.json'), 'utf8'));
    let meta = addonMeta(pkg);
    let disabled = false;
    const rootTrees = new WeakMap();
    function rootTree(addonInstance) {
        let tree = rootTrees.get(addonInstance);
        if (!tree) {
            tree = addonInstance.treeGenerator(directory);
            rootTrees.set(addonInstance, tree);
        }
        return tree;
    }
    return {
        name: pkg.name,
        included(...args) {
            this._super.included.apply(this, args);
            ensureAutoImport(this);
            let parentOptions;
            if (shared_internals_1.isDeepAddonInstance(this)) {
                // our parent is an addon
                parentOptions = this.parent.options;
            }
            else {
                // our parent is the app
                parentOptions = this.app.options;
            }
            if (options.disabled) {
                disabled = options.disabled(parentOptions);
            }
        },
        treeForApp() {
            if (disabled) {
                return undefined;
            }
            let maybeAppJS = meta['app-js'];
            if (maybeAppJS) {
                const appJS = maybeAppJS;
                return new broccoli_funnel_1.default(rootTree(this), {
                    files: Object.values(appJS),
                    getDestinationPath(relativePath) {
                        for (let [exteriorName, interiorName] of Object.entries(appJS)) {
                            if (relativePath === interiorName) {
                                return exteriorName;
                            }
                        }
                        throw new Error(`bug in addonV1Shim, no match for ${relativePath} in ${JSON.stringify(appJS)}`);
                    },
                });
            }
        },
        treeForAddon() {
            // this never goes through broccoli -- it's always pulled into the app via
            // ember-auto-import, as needed. This means it always benefits from
            // tree-shaking.
            return undefined;
        },
        treeForPublic() {
            if (disabled) {
                return undefined;
            }
            let maybeAssets = meta['public-assets'];
            if (maybeAssets) {
                const assets = maybeAssets;
                return new broccoli_funnel_1.default(rootTree(this), {
                    files: Object.keys(assets),
                    getDestinationPath(relativePath) {
                        for (let [interiorName, exteriorName] of Object.entries(assets)) {
                            if (relativePath === interiorName) {
                                return exteriorName;
                            }
                        }
                        throw new Error(`bug in addonV1Shim, no match for ${relativePath} in ${JSON.stringify(assets)}`);
                    },
                });
            }
        },
        isDevelopingAddon() {
            // if the app is inside our own directory, we must be under development.
            // This setting controls whether ember-cli will watch for changes in the
            // broccoli trees we expose, but it doesn't have any control over our
            // files that get auto-imported into the app. For that, you should use
            // ember-auto-import's watchDependencies option (and this should become
            // part of the blueprint for test apps).
            let appInstance = this._findHost();
            return isInside(directory, appInstance.project.root);
        },
    };
}
exports.addonV1Shim = addonV1Shim;
function isInside(parentDir, otherDir) {
    let rel = path_1.relative(parentDir, otherDir);
    return Boolean(rel) && !rel.startsWith('..') && !path_1.isAbsolute(rel);
}
function ensureAutoImport(instance) {
    var _a;
    let autoImport = instance.parent.addons.find((a) => a.name === 'ember-auto-import');
    if (!autoImport) {
        throw new Error(`${instance.name} is a v2-formatted addon. To use it without Embroider, the package that depends on it (${parentName(instance)}) must have ember-auto-import.`);
    }
    let level = (_a = autoImport.v2AddonSupportLevel) !== null && _a !== void 0 ? _a : 0;
    if (level < MIN_SUPPORT_LEVEL) {
        throw new Error(`${instance.name} is using v2 addon features that require a newer ember-auto-import than the one that is present in ${parentName(instance)}`);
    }
}
function parentName(instance) {
    if (shared_internals_1.isDeepAddonInstance(instance)) {
        return instance.parent.name;
    }
    else {
        return instance.parent.name();
    }
}
//# sourceMappingURL=shim.js.map